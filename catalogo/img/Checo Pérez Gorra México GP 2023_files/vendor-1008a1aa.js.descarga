function cloneProps(props){return Object.keys(props).reduce(((memo,k)=>{const prop=props[k];var val;return memo[k]=Object.assign({},prop),isObject(prop.value)&&(val=prop.value,"[object Function]"!==Object.prototype.toString.call(val))&&!Array.isArray(prop.value)&&(memo[k].value=Object.assign({},prop.value)),Array.isArray(prop.value)&&(memo[k].value=prop.value.slice(0)),memo}),{})}function parseAttributeValue(value){if(value)try{return JSON.parse(value)}catch(err){return value}}function reflect(node,attribute,value){if(null==value||!1===value)return node.removeAttribute(attribute);let reflect2=JSON.stringify(value);node.__updating[attribute]=!0,"true"===reflect2&&(reflect2=""),node.setAttribute(attribute,reflect2),Promise.resolve().then((()=>delete node.__updating[attribute]))}function isObject(obj){return null!=obj&&("object"==typeof obj||"function"==typeof obj)}let currentElement;function createElementType(BaseElement,propDefinition){const propKeys=Object.keys(propDefinition);return class extends BaseElement{static get observedAttributes(){return propKeys.map((k=>propDefinition[k].attribute))}constructor(){super(),this.__initialized=!1,this.__released=!1,this.__releaseCallbacks=[],this.__propertyChangedCallbacks=[],this.__updating={},this.props={}}connectedCallback(){if(this.__initialized)return;this.__releaseCallbacks=[],this.__propertyChangedCallbacks=[],this.__updating={},this.props=function(element,propDefinition){const props=cloneProps(propDefinition);return Object.keys(propDefinition).forEach((key=>{const prop=props[key],attr=element.getAttribute(prop.attribute),value=element[key];attr&&(prop.value=prop.parse?parseAttributeValue(attr):attr),null!=value&&(prop.value=Array.isArray(value)?value.slice(0):value),prop.reflect&&reflect(element,prop.attribute,prop.value),Object.defineProperty(element,key,{get:()=>prop.value,set(val){const oldValue=prop.value;prop.value=val,prop.reflect&&reflect(this,prop.attribute,prop.value);for(let i=0,l=this.__propertyChangedCallbacks.length;i<l;i++)this.__propertyChangedCallbacks[i](key,val,oldValue)},enumerable:!0,configurable:!0})})),props}(this,propDefinition);const props=function(props){return Object.keys(props).reduce(((memo,k)=>(memo[k]=props[k].value,memo)),{})}(this.props),ComponentType=this.Component,outerElement=currentElement;try{currentElement=this,this.__initialized=!0,"function"==typeof(f=ComponentType)&&0===f.toString().indexOf("class")?new ComponentType(props,{element:this}):ComponentType(props,{element:this})}finally{currentElement=outerElement}var f}async disconnectedCallback(){if(await Promise.resolve(),this.isConnected)return;this.__propertyChangedCallbacks.length=0;let callback=null;for(;callback=this.__releaseCallbacks.pop();)callback(this);delete this.__initialized,this.__released=!0}attributeChangedCallback(name,oldVal,newVal){if(this.__initialized&&!this.__updating[name]&&(name=this.lookupProp(name))in propDefinition){if(null==newVal&&!this[name])return;this[name]=propDefinition[name].parse?parseAttributeValue(newVal):newVal}}lookupProp(attrName){if(propDefinition)return propKeys.find((k=>attrName===k||attrName===propDefinition[k].attribute))}get renderRoot(){return this.shadowRoot||this.attachShadow({mode:"open"})}addReleaseCallback(fn){this.__releaseCallbacks.push(fn)}addPropertyChangedCallback(fn){this.__propertyChangedCallbacks.push(fn)}}}function compose(...fns){return 0===fns.length?i=>i:1===fns.length?fns[0]:fns.reduce(((a,b)=>(...args)=>a(b(...args))))}function register(tag,props={},options={}){const{BaseElement:BaseElement=HTMLElement,extension:extension}=options;return ComponentType=>{if(!tag)throw new Error("tag is required to register a Component");let ElementType=customElements.get(tag);return ElementType?(ElementType.prototype.Component=ComponentType,ElementType):(ElementType=createElementType(BaseElement,function(props){return props?Object.keys(props).reduce(((memo,k)=>{const v=props[k];return memo[k]=isObject(v)&&"value"in v?v:{value:v},memo[k].attribute||(memo[k].attribute=k.replace(/\.?([A-Z]+)/g,((x,y)=>"-"+y.toLowerCase())).replace("_","-").replace(/^-/,"")),memo[k].parse="parse"in memo[k]?memo[k].parse:"string"!=typeof memo[k].value,memo}),{}):{}}(props)),ElementType.prototype.Component=ComponentType,ElementType.prototype.registeredTag=tag,customElements.define(tag,ElementType,extension),ElementType)}}const sharedConfig={};const $TRACK=Symbol("solid-track"),$DEVCOMP=Symbol("solid-dev-component"),signalOptions={equals:(a,b)=>a===b};let runEffects=runQueue;const STALE=1,PENDING=2,UNOWNED={owned:null,cleanups:null,context:null,owner:null};var Owner=null;let Transition=null,Listener=null,Updates=null,Effects=null,ExecCount=0,rootCount=0;function createRoot(fn,detachedOwner){const listener=Listener,owner=Owner,unowned=0===fn.length,root=unowned?{owned:null,cleanups:null,context:null,owner:null}:{owned:null,cleanups:null,context:null,owner:void 0===detachedOwner?owner:detachedOwner},updateFn=unowned?()=>fn((()=>{throw new Error("Dispose method must be an explicit argument to createRoot function")})):()=>fn((()=>untrack((()=>cleanNode(root)))));owner&&(root.name=`${owner.name}-r${rootCount++}`),globalThis._$afterCreateRoot&&globalThis._$afterCreateRoot(root),Owner=root,Listener=null;try{return runUpdates(updateFn,!0)}finally{Listener=listener,Owner=owner}}function createSignal(value,options){const s={value:value,observers:null,observerSlots:null,comparator:(options=options?Object.assign({},signalOptions,options):signalOptions).equals||void 0};options.internal||(s.name=function(name,value){let tryName=name;if(Owner){let i=0;for(Owner.sourceMap||(Owner.sourceMap={});Owner.sourceMap[tryName];)tryName=`${name}-${++i}`;Owner.sourceMap[tryName]=value,value.graph=Owner}return tryName}(options.name||function(v){const s=new Set;return`s${hash("string"==typeof v?v:untrack((()=>JSON.stringify(v,((k,v2)=>{if("object"==typeof v2&&null!=v2){if(s.has(v2))return;s.add(v2);const keys=Object.keys(v2),desc=Object.getOwnPropertyDescriptors(v2),newDesc=keys.reduce(((memo,key)=>{const value=desc[key];return value.get||(memo[key]=value),memo}),{});v2=Object.create({},newDesc)}return"bigint"==typeof v2?`${v2.toString()}n`:v2}))||"")))}`}(value),s));return[readSignal.bind(s),value2=>("function"==typeof value2&&(value2=value2(s.value)),writeSignal(s,value2))]}function createRenderEffect(fn,value,options){updateComputation(createComputation(fn,value,!1,STALE,options))}function createEffect(fn,value,options){runEffects=runUserEffects;const c=createComputation(fn,value,!1,STALE,options);c.user=!0,Effects?Effects.push(c):updateComputation(c)}function createMemo(fn,value,options){const c=createComputation(fn,value,!0,0,options=options?Object.assign({},signalOptions,options):signalOptions);return c.observers=null,c.observerSlots=null,c.comparator=options.equals||void 0,updateComputation(c),readSignal.bind(c)}function untrack(fn){if(null===Listener)return fn();const listener=Listener;Listener=null;try{return fn()}finally{Listener=listener}}function onMount(fn){createEffect((()=>untrack(fn)))}function onCleanup(fn){return null===Owner?console.warn("cleanups created outside a `createRoot` or `render` will never be run"):null===Owner.cleanups?Owner.cleanups=[fn]:Owner.cleanups.push(fn),fn}function readSignal(){const runningTransition=Transition;if(this.sources&&(this.state||runningTransition))if(this.state===STALE||runningTransition)updateComputation(this);else{const updates=Updates;Updates=null,runUpdates((()=>lookUpstream(this)),!1),Updates=updates}if(Listener){const sSlot=this.observers?this.observers.length:0;Listener.sources?(Listener.sources.push(this),Listener.sourceSlots.push(sSlot)):(Listener.sources=[this],Listener.sourceSlots=[sSlot]),this.observers?(this.observers.push(Listener),this.observerSlots.push(Listener.sources.length-1)):(this.observers=[Listener],this.observerSlots=[Listener.sources.length-1])}return this.value}function writeSignal(node,value,isComp){let current=node.value;return node.comparator&&node.comparator(current,value)||(node.value=value,node.observers&&node.observers.length&&runUpdates((()=>{for(let i=0;i<node.observers.length;i+=1){const o=node.observers[i],TransitionRunning=Transition&&Transition.running;TransitionRunning&&Transition.disposed.has(o),(TransitionRunning&&!o.tState||!TransitionRunning&&!o.state)&&(o.pure?Updates.push(o):Effects.push(o),o.observers&&markDownstream(o)),TransitionRunning||(o.state=STALE)}if(Updates.length>1e6)throw Updates=[],new Error("Potential Infinite Loop Detected.")}),!1)),value}function updateComputation(node){if(!node.fn)return;cleanNode(node);const owner=Owner,listener=Listener,time=ExecCount;Listener=Owner=node,function(node,value,time){let nextValue;try{nextValue=node.fn(value)}catch(err){node.pure&&(node.state=STALE,node.owned&&node.owned.forEach(cleanNode),node.owned=null),handleError(err)}(!node.updatedAt||node.updatedAt<=time)&&(null!=node.updatedAt&&"observers"in node?writeSignal(node,nextValue):node.value=nextValue,node.updatedAt=time)}(node,node.value,time),Listener=listener,Owner=owner}function createComputation(fn,init,pure,state=STALE,options){const c={fn:fn,state:state,updatedAt:null,owned:null,sources:null,sourceSlots:null,cleanups:null,value:init,owner:Owner,context:null,pure:pure};return null===Owner?console.warn("computations created outside a `createRoot` or `render` will never be disposed"):Owner!==UNOWNED&&(Owner.owned?Owner.owned.push(c):Owner.owned=[c],c.name=options&&options.name||`${Owner.name||"c"}-${(Owner.owned||Owner.tOwned).length}`),c}function runTop(node){const runningTransition=Transition;if(0===node.state||runningTransition)return;if(node.state===PENDING||runningTransition)return lookUpstream(node);if(node.suspense&&untrack(node.suspense.inFallback))return node.suspense.effects.push(node);const ancestors=[node];for(;(node=node.owner)&&(!node.updatedAt||node.updatedAt<ExecCount);)(node.state||runningTransition)&&ancestors.push(node);for(let i=ancestors.length-1;i>=0;i--)if((node=ancestors[i]).state===STALE||runningTransition)updateComputation(node);else if(node.state===PENDING||runningTransition){const updates=Updates;Updates=null,runUpdates((()=>lookUpstream(node,ancestors[0])),!1),Updates=updates}}function runUpdates(fn,init){if(Updates)return fn();let wait=!1;init||(Updates=[]),Effects?wait=!0:Effects=[],ExecCount++;try{const res=fn();return function(wait){Updates&&(runQueue(Updates),Updates=null);if(wait)return;const e=Effects;Effects=null,e.length?runUpdates((()=>runEffects(e)),!1):globalThis._$afterUpdate&&globalThis._$afterUpdate()}(wait),res}catch(err){wait||(Effects=null),Updates=null,handleError(err)}}function runQueue(queue){for(let i=0;i<queue.length;i++)runTop(queue[i])}function runUserEffects(queue){let i,userLength=0;for(i=0;i<queue.length;i++){const e=queue[i];e.user?queue[userLength++]=e:runTop(e)}var context;for(sharedConfig.context&&(sharedConfig.context=context),i=0;i<userLength;i++)runTop(queue[i])}function lookUpstream(node,ignore){const runningTransition=Transition;node.state=0;for(let i=0;i<node.sources.length;i+=1){const source=node.sources[i];source.sources&&(source.state===STALE||runningTransition?source!==ignore&&runTop(source):(source.state===PENDING||runningTransition)&&lookUpstream(source,ignore))}}function markDownstream(node){const runningTransition=Transition;for(let i=0;i<node.observers.length;i+=1){const o=node.observers[i];o.state&&!runningTransition||(o.state=PENDING,o.pure?Updates.push(o):Effects.push(o),o.observers&&markDownstream(o))}}function cleanNode(node){let i;if(node.sources)for(;node.sources.length;){const source=node.sources.pop(),index=node.sourceSlots.pop(),obs=source.observers;if(obs&&obs.length){const n=obs.pop(),s=source.observerSlots.pop();index<obs.length&&(n.sourceSlots[s]=index,obs[index]=n,source.observerSlots[index]=s)}}if(node.owned){for(i=0;i<node.owned.length;i++)cleanNode(node.owned[i]);node.owned=null}if(node.cleanups){for(i=0;i<node.cleanups.length;i++)node.cleanups[i]();node.cleanups=null}node.state=0,node.context=null,delete node.sourceMap}function handleError(err){throw err=function(err){return err instanceof Error||"string"==typeof err?err:new Error("Unknown error")}(err)}function hash(s){for(var i=0,h=9;i<s.length;)h=Math.imul(h^s.charCodeAt(i++),9**9);return""+(h^h>>>9)}const FALLBACK=Symbol("fallback");function dispose(d){for(let i=0;i<d.length;i++)d[i]()}function createComponent(Comp,props){return function(Comp,props){const c=createComputation((()=>untrack((()=>(Object.assign(Comp,{[$DEVCOMP]:!0}),Comp(props))))),void 0,!0,0);return c.props=props,c.observers=null,c.observerSlots=null,c.componentName=Comp.name,updateComputation(c),void 0!==c.tValue?c.tValue:c.value}(Comp,props||{})}function For(props){const fallback="fallback"in props&&{fallback:()=>props.fallback};return createMemo(function(list,mapFn,options={}){let items=[],mapped=[],disposers=[],len=0,indexes=mapFn.length>1?[]:null;return onCleanup((()=>dispose(disposers))),()=>{let i,j,newItems=list()||[];return newItems[$TRACK],untrack((()=>{let newIndices,newIndicesNext,temp,tempdisposers,tempIndexes,start,end,newEnd,item,newLen=newItems.length;if(0===newLen)0!==len&&(dispose(disposers),disposers=[],items=[],mapped=[],len=0,indexes&&(indexes=[])),options.fallback&&(items=[FALLBACK],mapped[0]=createRoot((disposer=>(disposers[0]=disposer,options.fallback()))),len=1);else if(0===len){for(mapped=new Array(newLen),j=0;j<newLen;j++)items[j]=newItems[j],mapped[j]=createRoot(mapper);len=newLen}else{for(temp=new Array(newLen),tempdisposers=new Array(newLen),indexes&&(tempIndexes=new Array(newLen)),start=0,end=Math.min(len,newLen);start<end&&items[start]===newItems[start];start++);for(end=len-1,newEnd=newLen-1;end>=start&&newEnd>=start&&items[end]===newItems[newEnd];end--,newEnd--)temp[newEnd]=mapped[end],tempdisposers[newEnd]=disposers[end],indexes&&(tempIndexes[newEnd]=indexes[end]);for(newIndices=new Map,newIndicesNext=new Array(newEnd+1),j=newEnd;j>=start;j--)item=newItems[j],i=newIndices.get(item),newIndicesNext[j]=void 0===i?-1:i,newIndices.set(item,j);for(i=start;i<=end;i++)item=items[i],j=newIndices.get(item),void 0!==j&&-1!==j?(temp[j]=mapped[i],tempdisposers[j]=disposers[i],indexes&&(tempIndexes[j]=indexes[i]),j=newIndicesNext[j],newIndices.set(item,j)):disposers[i]();for(j=start;j<newLen;j++)j in temp?(mapped[j]=temp[j],disposers[j]=tempdisposers[j],indexes&&(indexes[j]=tempIndexes[j],indexes[j](j))):mapped[j]=createRoot(mapper);mapped=mapped.slice(0,len=newLen),items=newItems.slice(0)}return mapped}));function mapper(disposer){if(disposers[j]=disposer,indexes){const[s,set]=createSignal(j,{name:"index"});return indexes[j]=set,mapFn(newItems[j],s)}return mapFn(newItems[j])}}}((()=>props.each),props.children,fallback||void 0),void 0,{name:"value"})}function Show(props){let strictEqual=!1;const keyed=props.keyed,condition=createMemo((()=>props.when),void 0,{equals:(a,b)=>strictEqual?a===b:!a==!b,name:"condition"});return createMemo((()=>{const c=condition();if(c){const child=props.children,fn="function"==typeof child&&child.length>0;return strictEqual=keyed||fn,fn?untrack((()=>child(c))):child}return props.fallback}),void 0,{name:"value"})}globalThis&&(globalThis.Solid$$?console.warn("You appear to have multiple instances of Solid. This can lead to unexpected behavior."):globalThis.Solid$$=!0);function template(html,check,isSVG){const t=document.createElement("template");if(t.innerHTML=html,check&&t.innerHTML.split("<").length-1!==check)throw`The browser resolved template HTML does not match JSX input:\n${t.innerHTML}\n\n${html}. Is your HTML properly formed?`;let node=t.content.firstChild;return isSVG&&(node=node.firstChild),node}function delegateEvents(eventNames,document2=window.document){const e=document2._$DX_DELEGATE||(document2._$DX_DELEGATE=new Set);for(let i=0,l=eventNames.length;i<l;i++){const name=eventNames[i];e.has(name)||(e.add(name),document2.addEventListener(name,eventHandler))}}function setAttribute(node,name,value){null==value?node.removeAttribute(name):node.setAttribute(name,value)}function className(node,value){null==value?node.removeAttribute("class"):node.className=value}function style(node,value,prev){if(!value)return prev?setAttribute(node,"style"):value;const nodeStyle=node.style;if("string"==typeof value)return nodeStyle.cssText=value;let v,s;for(s in"string"==typeof prev&&(nodeStyle.cssText=prev=void 0),prev||(prev={}),value||(value={}),prev)null==value[s]&&nodeStyle.removeProperty(s),delete prev[s];for(s in value)v=value[s],v!==prev[s]&&(nodeStyle.setProperty(s,v),prev[s]=v);return prev}function insert(parent,accessor,marker,initial){if(void 0===marker||initial||(initial=[]),"function"!=typeof accessor)return insertExpression(parent,accessor,initial,marker);createRenderEffect((current=>insertExpression(parent,accessor(),current,marker)),initial)}function eventHandler(e){const key=`$$${e.type}`;let node=e.composedPath&&e.composedPath()[0]||e.target;for(e.target!==node&&Object.defineProperty(e,"target",{configurable:!0,value:node}),Object.defineProperty(e,"currentTarget",{configurable:!0,get:()=>node||document}),sharedConfig.registry&&!sharedConfig.done&&(sharedConfig.done=!0,document.querySelectorAll("[id^=pl-]").forEach((elem=>{for(;elem&&8!==elem.nodeType&&elem.nodeValue!=="pl-"+e;){let x=elem.nextSibling;elem.remove(),elem=x}elem&&elem.remove()})));node;){const handler=node[key];if(handler&&!node.disabled){const data=node[`${key}Data`];if(void 0!==data?handler.call(node,data,e):handler.call(node,e),e.cancelBubble)return}node=node._$host||node.parentNode||node.host}}function insertExpression(parent,value,current,marker,unwrapArray){for(sharedConfig.context&&!current&&(current=[...parent.childNodes]);"function"==typeof current;)current=current();if(value===current)return current;const t=typeof value,multi=void 0!==marker;if(parent=multi&&current[0]&&current[0].parentNode||parent,"string"===t||"number"===t){if(sharedConfig.context)return current;if("number"===t&&(value=value.toString()),multi){let node=current[0];node&&3===node.nodeType?node.data=value:node=document.createTextNode(value),current=cleanChildren(parent,current,marker,node)}else current=""!==current&&"string"==typeof current?parent.firstChild.data=value:parent.textContent=value}else if(null==value||"boolean"===t){if(sharedConfig.context)return current;current=cleanChildren(parent,current,marker)}else{if("function"===t)return createRenderEffect((()=>{let v=value();for(;"function"==typeof v;)v=v();current=insertExpression(parent,v,current,marker)})),()=>current;if(Array.isArray(value)){const array=[],currentArray=current&&Array.isArray(current);if(normalizeIncomingArray(array,value,current,unwrapArray))return createRenderEffect((()=>current=insertExpression(parent,array,current,marker,!0))),()=>current;if(sharedConfig.context){if(!array.length)return current;for(let i=0;i<array.length;i++)if(array[i].parentNode)return current=array}if(0===array.length){if(current=cleanChildren(parent,current,marker),multi)return current}else currentArray?0===current.length?appendNodes(parent,array,marker):function(parentNode,a,b){let bLength=b.length,aEnd=a.length,bEnd=bLength,aStart=0,bStart=0,after=a[aEnd-1].nextSibling,map=null;for(;aStart<aEnd||bStart<bEnd;)if(a[aStart]!==b[bStart]){for(;a[aEnd-1]===b[bEnd-1];)aEnd--,bEnd--;if(aEnd===aStart){const node=bEnd<bLength?bStart?b[bStart-1].nextSibling:b[bEnd-bStart]:after;for(;bStart<bEnd;)parentNode.insertBefore(b[bStart++],node)}else if(bEnd===bStart)for(;aStart<aEnd;)map&&map.has(a[aStart])||a[aStart].remove(),aStart++;else if(a[aStart]===b[bEnd-1]&&b[bStart]===a[aEnd-1]){const node=a[--aEnd].nextSibling;parentNode.insertBefore(b[bStart++],a[aStart++].nextSibling),parentNode.insertBefore(b[--bEnd],node),a[aEnd]=b[bEnd]}else{if(!map){map=new Map;let i=bStart;for(;i<bEnd;)map.set(b[i],i++)}const index=map.get(a[aStart]);if(null!=index)if(bStart<index&&index<bEnd){let t,i=aStart,sequence=1;for(;++i<aEnd&&i<bEnd&&null!=(t=map.get(a[i]))&&t===index+sequence;)sequence++;if(sequence>index-bStart){const node=a[aStart];for(;bStart<index;)parentNode.insertBefore(b[bStart++],node)}else parentNode.replaceChild(b[bStart++],a[aStart++])}else aStart++;else a[aStart++].remove()}}else aStart++,bStart++}(parent,current,array):(current&&cleanChildren(parent),appendNodes(parent,array));current=array}else if(value instanceof Node){if(sharedConfig.context&&value.parentNode)return current=multi?[value]:value;if(Array.isArray(current)){if(multi)return current=cleanChildren(parent,current,marker,value);cleanChildren(parent,current,null,value)}else null!=current&&""!==current&&parent.firstChild?parent.replaceChild(value,parent.firstChild):parent.appendChild(value);current=value}else console.warn("Unrecognized value. Skipped inserting",value)}return current}function normalizeIncomingArray(normalized,array,current,unwrap){let dynamic=!1;for(let i=0,len=array.length;i<len;i++){let item=array[i],prev=current&&current[i];if(item instanceof Node)normalized.push(item);else if(null==item||!0===item||!1===item);else if(Array.isArray(item))dynamic=normalizeIncomingArray(normalized,item,prev)||dynamic;else if("function"==typeof item)if(unwrap){for(;"function"==typeof item;)item=item();dynamic=normalizeIncomingArray(normalized,Array.isArray(item)?item:[item],Array.isArray(prev)?prev:[prev])||dynamic}else normalized.push(item),dynamic=!0;else{const value=String(item);prev&&3===prev.nodeType&&prev.data===value?normalized.push(prev):normalized.push(document.createTextNode(value))}}return dynamic}function appendNodes(parent,array,marker=null){for(let i=0,len=array.length;i<len;i++)parent.insertBefore(array[i],marker)}function cleanChildren(parent,current,marker,replacement){if(void 0===marker)return parent.textContent="";const node=replacement||document.createTextNode("");if(current.length){let inserted=!1;for(let i=current.length-1;i>=0;i--){const el=current[i];if(node!==el){const isParent=el.parentNode===parent;inserted||i?isParent&&el.remove():isParent?parent.replaceChild(node,el):parent.insertBefore(node,marker)}else inserted=!0}}else parent.insertBefore(node,marker);return[node]}function withSolid(ComponentType){return(rawProps,options)=>{const{element:element}=options;return createRoot((dispose2=>{const props=function(raw){const keys=Object.keys(raw),props={};for(let i=0;i<keys.length;i++){const[get,set]=createSignal(raw[keys[i]]);Object.defineProperty(props,keys[i],{get:get,set(v){set((()=>v))}})}return props}(rawProps);element.addPropertyChangedCallback(((key,val)=>props[key]=val)),element.addReleaseCallback((()=>{element.renderRoot.textContent="",dispose2()}));const comp=ComponentType(props,options);return insert(element.renderRoot,comp)}),function(el){if(el.assignedSlot&&el.assignedSlot._$owner)return el.assignedSlot._$owner;let next=el.parentNode;for(;next&&!next._$owner&&(!next.assignedSlot||!next.assignedSlot._$owner);)next=next.parentNode;return next&&next.assignedSlot?next.assignedSlot._$owner:el._$owner}(element))}}export{For as F,Show as S,createEffect as a,createComponent as b,createSignal as c,createRenderEffect as d,className as e,setAttribute as f,compose as g,delegateEvents as h,insert as i,onCleanup as j,createMemo as k,onMount as o,register as r,style as s,template as t,withSolid as w};
